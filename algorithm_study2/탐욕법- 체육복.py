# 프로그래머스 탐욕법 - 체육복

def solution(n, lost, reserve):
    # 프로그래머스 방법 (2)
    # KLogK (K는 여벌을 가지고 있는 학생의 수)
    # 전체 학생의 수는 매우 큰데, 여벌을 가지고 있는 학생의 수가 매우 적을때
    s = set(lost) & set(reserve)  # 체육복을 가져왔는데 잃어버린 학생들, 고려하지 않을 학생들 먼저 추출, 교집합
    l = set(lost) - s  # 빌려야 하는 학생, 차집합, (잃어버린 학생 : lost - 가져왔는데 잃어버린 학생 : s)
    r = set(reserve) - s  # 체육복 2개 있는 학생, 차집합, (빌려줄 수 있는 학생 : reserve - 가져왔는데 잃어버린 학생 : s)

    for x in sorted(r):  # sorted()하면 크기 순으로 정렬 후 리스트로 변환됨
        if x - 1 in l:  # x의 앞의 학생이 l에 들어 있으면 삭제
            l.remove(x - 1)
        elif x + 1 in l:  # x의 뒤의 학생이 l에 들어 있으면 삭제
            l.remove(x + 1)

    return n - len(l)

    # 프로그래머스 방법 (1)
    # LogN (N은 전체 학생 수)
    # 전체 학생의 수와 여분이 있는 학생의 수, 잃어버린 학생의 수가 크게 차이나지 않을 떄

    # u = [1] * (n + 2)  # 구현의 편의성을 위해 맨 앞, 맨 뒤에 [1]을 하나씩 추가 한다.
    #
    # for i in reserve:  # 여벌의 체육복을 가지고 있는 학생을 순회해 u list에 하나씩 추가한다.
    #     u[i] += 1
    # for i in lost:  # 마찬가지로 체육복을 잃어버린 학생들을 u list에서 하나씩 차감한다.
    #     u[i] -= 1
    # for i in range(1, n + 1):  # 1번 부터 n번까지
    #     if u[i - 1] == 0 and u[i] == 2:  # 앞 사람 한테 빌려줌 왼쪽부터 순회하기떄문에, 앞사람이 우선되야함
    #         u[i - 1:i + 1] = [1, 1]  # i-1 부터 i 까지
    #     elif u[i] == 2 and u[i + 1] == 0:  # 뒷 사람한테 빌려주는 경우
    #         u[i:i + 2] = [1, 1]  # i 부터 i+1 까지
    #     # 맨앞, 맨 뒤의 여분을 두었기 떄문에 간단하게 앞,뒤사람에게 빌려줄 수 있다.
    #
    # return len([i for i in u[1:-1] if i > 0])  # u의 1부터 길이 끝에서 -1 까지 의 0이상 수

